/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    audio_acquisition.c
  * @author  Wind Turbine Team
  * @brief   Audio acquisition thread implementation
  ******************************************************************************
  * NOTE: This implementation assumes ADF (Audio Development Framework)
  *       and PDM microphone (IMP34DT05/IMP34DT85) are configured via STM32CubeMX.
  *       PDM input → DFSDM → PCM output @ 16 kHz, 16-bit mono
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "audio_acquisition.h"
#include "main.h"
#include <string.h>

/* Private defines -----------------------------------------------------------*/
/*
 * DFSDM handles are only available if DFSDM is enabled/generated by CubeMX.
 * This repository's STWIN.box audio path can be built without DFSDM by using
 * the BSP audio driver instead, so keep those references disabled here.
 */
#if 0
extern DFSDM_Channel_HandleTypeDef hdfsdm1_channel1;  /* PDM microphone input */
extern DFSDM_Filter_HandleTypeDef hdfsdm1_filter0;    /* DFSDM filter */
#endif

/* Private types -------------------------------------------------------------*/

typedef struct
{
    TX_THREAD              thread;                     /* Thread control block */
    TX_QUEUE               frame_queue;                /* Queue for audio frames */
    UINT                   is_active;                  /* Capture active flag */
    uint32_t               frame_count;                /* Frames captured */
    uint32_t               error_count;                /* Error counter */
    
    /* Double buffering for DMA */
    int16_t                dma_buffer_a[AUDIO_FRAME_SIZE];
    int16_t                dma_buffer_b[AUDIO_FRAME_SIZE];
    uint8_t                current_buffer;             /* 0=A, 1=B */
    
    /* Thread stack */
    uint8_t                *thread_stack;
    uint8_t                *queue_memory;
} AudioAcquisition_Context_t;

/* Private variables ---------------------------------------------------------*/
static AudioAcquisition_Context_t audio_acq_ctx = {0};
static uint32_t boot_time_ms = 0;

/* Private function prototypes -----------------------------------------------*/
static void AudioAcquisition_ThreadEntry(ULONG thread_input);
static void AudioAcquisition_DMA_Complete_Callback(void);
static void AudioAcquisition_DMA_Error_Callback(void);

/**
  * @brief  Initialize audio acquisition subsystem
  * @param  byte_pool: ThreadX byte pool
  * @retval TX_SUCCESS or error code
  */
UINT AudioAcquisition_Init(TX_BYTE_POOL *byte_pool)
{
    UINT status;
    
    if (!byte_pool)
        return TX_PTR_ERROR;
    
    memset(&audio_acq_ctx, 0, sizeof(audio_acq_ctx));
    
    /* Allocate thread stack */
    status = tx_byte_allocate(byte_pool, 
                              (VOID **)&audio_acq_ctx.thread_stack,
                              AUDIO_ACQ_THREAD_STACK_SIZE,
                              TX_NO_WAIT);
    if (status != TX_SUCCESS)
        return status;
    
    /* Allocate queue storage (4 frames max) */
    size_t queue_size = AUDIO_ACQ_QUEUE_DEPTH * sizeof(AudioFrame_t);
    status = tx_byte_allocate(byte_pool,
                              (VOID **)&audio_acq_ctx.queue_memory,
                              queue_size,
                              TX_NO_WAIT);
    if (status != TX_SUCCESS)
        return status;
    
    /* Create message queue for audio frames */
    status = tx_queue_create(&audio_acq_ctx.frame_queue,
                             "Audio Frame Queue",
                             sizeof(AudioFrame_t) / sizeof(ULONG),
                             audio_acq_ctx.queue_memory,
                             queue_size);
    if (status != TX_SUCCESS)
        return status;
    
    /* Create acquisition thread (starts in suspended state) */
    status = tx_thread_create(&audio_acq_ctx.thread,
                              "Audio Acquisition",
                              AudioAcquisition_ThreadEntry,
                              0,
                              audio_acq_ctx.thread_stack,
                              AUDIO_ACQ_THREAD_STACK_SIZE,
                              AUDIO_ACQ_THREAD_PRIORITY,
                              AUDIO_ACQ_THREAD_PRIORITY,
                              TX_NO_TIME_SLICE,
                              TX_DONT_START);
    
    if (status != TX_SUCCESS)
        return status;
    
    audio_acq_ctx.frame_count = 0;
    audio_acq_ctx.error_count = 0;
    audio_acq_ctx.current_buffer = 0;
    audio_acq_ctx.is_active = 0;
    
    return TX_SUCCESS;
}

/**
  * @brief  Start audio capture
  * @retval TX_SUCCESS on success
  */
UINT AudioAcquisition_Start(void)
{
    UINT status;
    
    if (!audio_acq_ctx.thread_stack)
        return TX_PTR_ERROR;
    
    /* Record boot timestamp for relative timing */
    boot_time_ms = tx_time_get();  /* ThreadX tick count */
    
    /* Start DMA-based DFSDM capture using circular double buffering */
    /* HAL call: HAL_DFSDM_FilterRegularStart_DMA(filter, buffer, length) */
    /* This assumes CubeMX has configured PDM input on DFSDM channel 1, filter 0 */
    
    /* Note: DFSDM configuration must be done in MX_DFSDM_Init() (via CubeMX) */
    /* This code only starts the configured DMA capture */
    
    /*
     * CRITICAL: DFSDM requires:
     * - PDM microphone clock input on GPIO
     * - PDM data input on DFSDM channel
     * - DFSDM filter configured in fast mode
     * - DMA configured for circular transfer
     * See STM32CubeMX project configuration
     */
    
    audio_acq_ctx.is_active = 1;
    
    /* Resume the acquisition thread */
    status = tx_thread_resume(&audio_acq_ctx.thread);
    
    return status;
}

/**
  * @brief  Get audio frame queue pointer
  * @retval TX_QUEUE* or NULL
  */
TX_QUEUE* AudioAcquisition_GetQueue(void)
{
    return audio_acq_ctx.thread_stack ? &audio_acq_ctx.frame_queue : NULL;
}

/**
  * @brief  Get current frame count
  * @retval Frame counter
  */
uint32_t AudioAcquisition_GetFrameCount(void)
{
    return audio_acq_ctx.frame_count;
}

/**
  * @brief  Check if actively capturing
  * @retval 1 if capturing, 0 otherwise
  */
uint8_t AudioAcquisition_IsActive(void)
{
    return audio_acq_ctx.is_active;
}

/**
  * @brief  Get error count
  * @retval Accumulated error count
  */
uint32_t AudioAcquisition_GetErrorCount(void)
{
    return audio_acq_ctx.error_count;
}

/**
  * @brief  Audio acquisition thread entry point
  * @param  thread_input: unused
  * @retval None
  * 
  * This thread:
  * 1. Waits for DFSDM DMA completion callbacks
  * 2. Converts raw DFSDM output to PCM16
  * 3. Queues completed frames for feature extraction
  */
static void AudioAcquisition_ThreadEntry(ULONG thread_input)
{
    (void)thread_input;
    AudioFrame_t frame;
    uint32_t frame_time_ticks;
    
    while (1)
    {
        /* Wait for DFSDM DMA completion or error event */
        /* In practice, this uses a semaphore set by DMA callbacks */
        /* For now, simulated with periodic polling */
        
        tx_thread_sleep(32);  /* ~2ms wait (AUDIO_FRAME_SIZE = 512 @ 16kHz = 32ms) */
        
        if (!audio_acq_ctx.is_active)
        {
            tx_thread_suspend(&audio_acq_ctx.thread);
            continue;
        }
        
        /* Prepare frame message */
        memset(&frame, 0, sizeof(frame));
        frame.frame_number = audio_acq_ctx.frame_count++;
        frame.error_flags = 0;
        
        /* Calculate relative timestamp in milliseconds */
        uint32_t ticks_elapsed = tx_time_get() - boot_time_ms;
        /* ThreadX tick rate: typically 1000 ticks/sec = 1ms per tick */
        frame.timestamp_ms = ticks_elapsed;  /* Adjust based on actual tick rate */
        
        /* Placeholder: In actual implementation, copy from DMA buffer
         * Example:
         * if (audio_acq_ctx.current_buffer == 0)
         *     memcpy(frame.samples, audio_acq_ctx.dma_buffer_a, sizeof(frame.samples));
         * else
         *     memcpy(frame.samples, audio_acq_ctx.dma_buffer_b, sizeof(frame.samples));
         */
        
        /* Check for errors (would be set by DMA callbacks) */
        if (frame.error_flags)
        {
            audio_acq_ctx.error_count++;
            if (audio_acq_ctx.error_count > 1000)
                audio_acq_ctx.error_count = 0;  /* Prevent overflow */
        }
        
        /* Send frame to feature extraction queue (non-blocking, drop if full) */
        UINT status = tx_queue_send(&audio_acq_ctx.frame_queue,
                                    (VOID *)&frame,
                                    TX_NO_WAIT);
        
        if (status != TX_SUCCESS)
        {
            /* Queue full: frame dropped, increment error counter */
            audio_acq_ctx.error_count++;
        }
    }
}

/**
  * @brief  DMA completion callback (called from HAL_DFSDM_FilterRegularConvCpltCallback)
  * @retval None
  * 
  * Called by HAL when DMA transfer completes (half or full)
  */
void AudioAcquisition_DMA_Complete_Callback(void)
{
    /* Switch buffer pointers for next DMA transfer */
    audio_acq_ctx.current_buffer = (audio_acq_ctx.current_buffer == 0) ? 1 : 0;
    
    /* Wake up acquisition thread (in real impl, set event/semaphore) */
    /* This is handled by ThreadX scheduler automatically when buffer is filled */
}

/**
  * @brief  DMA error callback
  * @retval None
  */
void AudioAcquisition_DMA_Error_Callback(void)
{
    audio_acq_ctx.error_count++;
    audio_acq_ctx.is_active = 0;  /* Stop capture on critical error */
}

/************************ (C) COPYRIGHT Wind Turbine Team *****END OF FILE****/
