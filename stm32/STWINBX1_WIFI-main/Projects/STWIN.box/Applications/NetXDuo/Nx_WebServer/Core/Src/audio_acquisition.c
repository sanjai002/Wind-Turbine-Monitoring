/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    audio_acquisition.c
  * @author  Wind Turbine Team
  * @brief   Audio acquisition thread implementation
  ******************************************************************************
  * NOTE: This implementation assumes ADF (Audio Development Framework)
  *       and PDM microphone (IMP34DT05/IMP34DT85) are configured via STM32CubeMX.
  *       PDM input → DFSDM → PCM output @ 16 kHz, 16-bit mono
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "audio_acquisition.h"
#include "main.h"
#include "STWIN.box_audio.h"
#include <string.h>
#include <limits.h>

/* Private defines -----------------------------------------------------------*/
/*
 * DFSDM handles are only available if DFSDM is enabled/generated by CubeMX.
 * This repository's STWIN.box audio path can be built without DFSDM by using
 * the BSP audio driver instead, so keep those references disabled here.
 */
#if 0
extern DFSDM_Channel_HandleTypeDef hdfsdm1_channel1;  /* PDM microphone input */
extern DFSDM_Filter_HandleTypeDef hdfsdm1_filter0;    /* DFSDM filter */
#endif

/* Private types -------------------------------------------------------------*/

typedef struct
{
    TX_THREAD              thread;                     /* Thread control block */
    TX_QUEUE               frame_queue;                /* Queue for audio frames */
    UINT                   is_active;                  /* Capture active flag */
    uint32_t               frame_count;                /* Frames captured */
    uint32_t               error_count;                /* Error counter */
    
    /* Double buffering for DMA */
    int16_t                dma_buffer_a[AUDIO_FRAME_SIZE];
    int16_t                dma_buffer_b[AUDIO_FRAME_SIZE];
    uint8_t                current_buffer;             /* 0=A, 1=B */
    
    /* Thread stack */
    uint8_t                *thread_stack;
    uint8_t                *queue_memory;
} AudioAcquisition_Context_t;

/* Private variables ---------------------------------------------------------*/
static AudioAcquisition_Context_t audio_acq_ctx = {0};
static uint32_t boot_time_ms = 0;

/* Private function prototypes -----------------------------------------------*/
static void AudioAcquisition_ThreadEntry(ULONG thread_input);
static void AudioAcquisition_DMA_Complete_Callback(void);
static void AudioAcquisition_DMA_Error_Callback(void);

/**
  * @brief  Initialize audio acquisition subsystem
  * @param  byte_pool: ThreadX byte pool
  * @retval TX_SUCCESS or error code
  */
UINT AudioAcquisition_Init(TX_BYTE_POOL *byte_pool)
{
    UINT status;
    
    if (!byte_pool)
        return TX_PTR_ERROR;
    
    memset(&audio_acq_ctx, 0, sizeof(audio_acq_ctx));
    
    /* Allocate thread stack */
    status = tx_byte_allocate(byte_pool, 
                              (VOID **)&audio_acq_ctx.thread_stack,
                              AUDIO_ACQ_THREAD_STACK_SIZE,
                              TX_NO_WAIT);
    if (status != TX_SUCCESS)
        return status;
    
    /* Allocate queue storage (4 frames max) */
    size_t queue_size = AUDIO_ACQ_QUEUE_DEPTH * sizeof(AudioFrame_t);
    status = tx_byte_allocate(byte_pool,
                              (VOID **)&audio_acq_ctx.queue_memory,
                              queue_size,
                              TX_NO_WAIT);
    if (status != TX_SUCCESS)
        return status;
    
    /* Create message queue for audio frames */
    status = tx_queue_create(&audio_acq_ctx.frame_queue,
                             "Audio Frame Queue",
                             sizeof(AudioFrame_t) / sizeof(ULONG),
                             audio_acq_ctx.queue_memory,
                             queue_size);
    if (status != TX_SUCCESS)
        return status;
    
    /* Create acquisition thread (starts in suspended state) */
    status = tx_thread_create(&audio_acq_ctx.thread,
                              "Audio Acquisition",
                              AudioAcquisition_ThreadEntry,
                              0,
                              audio_acq_ctx.thread_stack,
                              AUDIO_ACQ_THREAD_STACK_SIZE,
                              AUDIO_ACQ_THREAD_PRIORITY,
                              AUDIO_ACQ_THREAD_PRIORITY,
                              TX_NO_TIME_SLICE,
                              TX_DONT_START);
    
    if (status != TX_SUCCESS)
        return status;
    
    audio_acq_ctx.frame_count = 0;
    audio_acq_ctx.error_count = 0;
    audio_acq_ctx.current_buffer = 0;
    audio_acq_ctx.is_active = 0;
    
    return TX_SUCCESS;
}

/**
  * @brief  Start audio capture
  * @retval TX_SUCCESS on success
  */
UINT AudioAcquisition_Start(void)
{
    UINT status;
    
    if (!audio_acq_ctx.thread_stack)
        return TX_PTR_ERROR;
    
    /* Record boot timestamp for relative timing */
    boot_time_ms = tx_time_get();  /* ThreadX tick count */
    
    /* Initialize BSP audio */
    BSP_AUDIO_Init_t audio_init;
    audio_init.Device = ONBOARD_DIGITAL_MIC_MASK;  /* Use digital microphone */
    audio_init.SampleRate = AUDIO_FREQUENCY_16K;  /* 16 kHz */
    audio_init.BitsPerSample = 16;  /* 16 bits */
    audio_init.ChannelsNbr = 1;  /* Mono */
    audio_init.Volume = 100;  /* Full volume */
    
    if (BSP_AUDIO_IN_Init(0, &audio_init) != BSP_ERROR_NONE)
    {
        audio_acq_ctx.error_count++;
        return TX_NOT_DONE;
    }
    
    audio_acq_ctx.is_active = 1;
    
    /* Resume the acquisition thread */
    status = tx_thread_resume(&audio_acq_ctx.thread);
    
    return status;
}

/**
  * @brief  Get audio frame queue pointer
  * @retval TX_QUEUE* or NULL
  */
TX_QUEUE* AudioAcquisition_GetQueue(void)
{
    return audio_acq_ctx.thread_stack ? &audio_acq_ctx.frame_queue : NULL;
}

/**
  * @brief  Get current frame count
  * @retval Frame counter
  */
uint32_t AudioAcquisition_GetFrameCount(void)
{
    return audio_acq_ctx.frame_count;
}

/**
  * @brief  Check if actively capturing
  * @retval 1 if capturing, 0 otherwise
  */
uint8_t AudioAcquisition_IsActive(void)
{
    return audio_acq_ctx.is_active;
}

/**
  * @brief  Get error count
  * @retval Accumulated error count
  */
uint32_t AudioAcquisition_GetErrorCount(void)
{
    return audio_acq_ctx.error_count;
}

/**
  * @brief  Audio acquisition thread entry point
  * @param  thread_input: unused
  * @retval None
  * 
  * This thread:
  * 1. Captures audio frames using BSP audio functions
  * 2. Converts raw audio data to PCM16
  * 3. Queues completed frames for feature extraction
  */
static void AudioAcquisition_ThreadEntry(ULONG thread_input)
{
    (void)thread_input;
    AudioFrame_t frame;
    uint8_t audio_buffer[AUDIO_FRAME_SIZE * 2];  /* 16-bit samples = 2 bytes per sample */
    
    while (1)
    {
        if (!audio_acq_ctx.is_active)
        {
            tx_thread_suspend(&audio_acq_ctx.thread);
            continue;
        }
        
        /* Capture one frame of audio data */
        /* AUDIO_FRAME_SIZE = 512 samples, each sample is 16-bit = 1024 bytes */
        if (BSP_AUDIO_IN_Record(0, audio_buffer, AUDIO_FRAME_SIZE * 2) != BSP_ERROR_NONE)
        {
            audio_acq_ctx.error_count++;
            tx_thread_sleep(32);  /* Wait before retry */
            continue;
        }
        
        /* Prepare frame message */
        memset(&frame, 0, sizeof(frame));
        frame.frame_number = audio_acq_ctx.frame_count++;
        frame.error_flags = 0;
        
        /* Calculate relative timestamp in milliseconds */
        uint32_t ticks_elapsed = tx_time_get() - boot_time_ms;
        /* ThreadX tick rate: typically 1000 ticks/sec = 1ms per tick */
        frame.timestamp_ms = ticks_elapsed;  /* Adjust based on actual tick rate */
        
        /* Convert raw audio buffer to int16_t samples */
        for (uint32_t i = 0; i < AUDIO_FRAME_SIZE; i++)
        {
            /* BSP returns data as uint8_t array, convert to int16_t */
            frame.samples[i] = (int16_t)((audio_buffer[i*2+1] << 8) | audio_buffer[i*2]);
        }
        
        /* Check for errors (clipping detection) */
        for (uint32_t i = 0; i < AUDIO_FRAME_SIZE; i++)
        {
            if (frame.samples[i] == INT16_MIN || frame.samples[i] == INT16_MAX)
            {
                frame.error_flags |= AUDIO_ACQ_ERROR_CLIPPING;
                break;
            }
        }
        
        if (frame.error_flags)
        {
            audio_acq_ctx.error_count++;
        }
        
        /* Send frame to feature extraction queue (non-blocking, drop if full) */
        UINT status = tx_queue_send(&audio_acq_ctx.frame_queue,
                                    (VOID *)&frame,
                                    TX_NO_WAIT);
        
        if (status != TX_SUCCESS)
        {
            /* Queue full: frame dropped, increment error counter */
            audio_acq_ctx.error_count++;
        }
        
        /* Frame rate: 512 samples @ 16kHz = 32ms per frame */
        /* Small delay to prevent busy-waiting */
        tx_thread_sleep(1);
    }
}

/**
  * @brief  DMA completion callback (called from HAL_DFSDM_FilterRegularConvCpltCallback)
  * @retval None
  * 
  * Called by HAL when DMA transfer completes (half or full)
  */
__attribute__((unused)) void AudioAcquisition_DMA_Complete_Callback(void)
{
    /* Switch buffer pointers for next DMA transfer */
    audio_acq_ctx.current_buffer = (audio_acq_ctx.current_buffer == 0) ? 1 : 0;
    
    /* Wake up acquisition thread (in real impl, set event/semaphore) */
    /* This is handled by ThreadX scheduler automatically when buffer is filled */
}

/**
  * @brief  DMA error callback
  * @retval None
  */
__attribute__((unused)) void AudioAcquisition_DMA_Error_Callback(void)
{
    audio_acq_ctx.error_count++;
    audio_acq_ctx.is_active = 0;  /* Stop capture on critical error */
}

/************************ (C) COPYRIGHT Wind Turbine Team *****END OF FILE****/
